# 动态点赞 / 收藏机器人拟真策略设计文档（最终版）

## 1. 文档背景与目标

在仅能获取**最近 100 条动态**的技术约束下，设计一套长期稳定、行为拟真的机器人点赞与收藏策略，用于：

- 覆盖 **当日 / 昨日 / 近7天 / 近15天** 不同时间窗的动态
- 各时间窗具备**可配置比例或权重**
- 行为模式尽量接近真人，降低被风控识别风险
- 支持多次运行、状态累积、随机扰动

---

## 2. 核心约束与风险分析

### 2.1 技术约束
- API 仅支持获取「最近 100 条动态」（时间倒序）
- 动态持续新增，旧内容会被快速挤出窗口
- 无法直接获取某一时间段的完整动态集合

### 2.2 典型风险行为
- 对可见动态点赞覆盖率过高（接近 100%）
- 点赞集中发生在短时间内
- 永远只点赞最新内容
- 点赞 / 收藏比例固定
- 每天行为模式高度一致

---

## 3. 设计总原则

> ❌ 按条顺序处理  
> ✅ 按「**每日预算 + 多时间窗分桶 + 随机抽样 + 多次消耗**」处理

核心原则：
1. 先确定“**今天要点多少**”，而不是“看到什么点什么”
2. 将动态按时间窗**互斥分桶**
3. 按权重分配每日预算
4. 多次运行逐步消耗预算
5. 所有关键行为均加入随机扰动

---

## 4. 时间窗定义（互斥分桶）

| Bucket | 时间范围 |
|------|---------|
| T0 | 当日（0 天） |
| T1 | 昨日（1 天） |
| T2 | 近 7 天（2～7 天） |
| T3 | 近 15 天（8～15 天） |
| T4 | 超过 15 天（默认不互动） |

> 任一动态只会进入一个桶，避免重复点赞策略冲突。

---

## 5. 每日点赞预算设计

### 5.1 每日总点赞预算
每日初始化一次：

```text
like_total_day = random(8, 20)
```

> 范围可配置，不建议固定。

---

### 5.2 时间窗权重分配（推荐默认）

| Bucket | 权重 |
|------|------|
| T0（当日） | 55% |
| T1（昨日） | 25% |
| T2（2–7天） | 15% |
| T3（8–15天） | 5% |

```text
like_budget_day[T_i] = round(like_total_day * weight[T_i])
```

---

### 5.3 覆盖率上限（强制）

防止桶内“全赞”：

| Bucket | 最大覆盖率 |
|------|-----------|
| T0 | ≤ 60% |
| T1 | ≤ 40% |
| T2 | ≤ 20% |
| T3 | ≤ 10% |

```text
like_budget_day[T_i] ≤ floor(count(T_i) * max_cover[T_i])
```

---

## 6. 单日多次运行策略

### 6.1 运行次数
- 每日运行：3～8 次
- 运行时间随机分布在全天

### 6.2 单次运行点赞数
- 每次运行：1～4 个赞
- 从各桶剩余预算中切片获取

```text
like_budget_run[T_i] = random(0, min(remaining[T_i], 2))
```

> 单次运行可混合多个桶，更接近真人浏览行为。

---

## 7. 点赞选择逻辑

### 7.1 候选筛选
- 来源：最近 100 条动态
- 过滤条件：
  - 已点赞的动态
  - 已收藏但未点赞的异常状态

### 7.2 抽样规则
1. 按发布时间分桶
2. 桶内 `shuffle`
3. 按预算 `pick N`
4. 不按时间顺序点赞

---

## 8. 收藏策略设计

### 8.1 基本原则
- 收藏只能发生在**已点赞**的动态上
- 收藏数量远少于点赞

### 8.2 数量与比例
- 点赞 : 收藏 ≈ 8 : 1 或 10 : 1
- 每日收藏：1～3 条
- 大多数运行不触发收藏

### 8.3 时间窗偏好
- 主要来源：T0 / T1
- T2 极低概率
- T3 默认不收藏

---

## 9. 行为节奏与延迟控制

### 9.1 点赞节奏
- 点赞间隔：30 秒 ～ 5 分钟（随机）
- 单次运行连续点赞 ≤ 3～5 条

### 9.2 收藏延迟
- 收藏发生在点赞之后
- 延迟：1 ～ 3 分钟

---

## 10. 状态记录（必须）

建议至少记录以下状态（按天）：

```text
- liked_post_ids（近15天）
- favorited_post_ids
- daily_like_budget_by_bucket
- daily_remaining_budget_by_bucket
- run_count_today
- last_run_time
```

> 无状态设计极易导致重复、失控或行为异常。

---

## 11. 异常与边界处理

- 桶内无动态 → 跳过
- 预算大于可用动态 → 自动缩减
- 接口失败：
  - 最多重试 1～2 次
  - 禁止死循环
- 随机异常日：
  - 10% 概率当天不点赞
  - 10% 概率当天只点赞 1 条

---

## 12. 伪代码示例

```pseudo
posts = fetch_latest_100()
buckets = split_into_buckets(posts)

state = load_daily_state()

if not state.initialized:
  like_total = rand(8, 20)
  state.allocate_by_weight(like_total)

for bucket in buckets:
  max_allowed = floor(count(bucket) * max_cover[bucket])
  state.remaining[bucket] = min(state.remaining[bucket], max_allowed)

run_budget = slice_run_budget(state.remaining)

for bucket in run_budget:
  candidates = shuffle(buckets[bucket])
  candidates = exclude_liked(candidates)
  to_like = pick(run_budget[bucket], candidates)

  for post in to_like:
    sleep rand(30..300)
    like(post)
    state.mark_liked(post)

if rand_prob < fav_prob:
  post = pick_from_recent_liked()
  sleep rand(60..180)
  favorite(post)

save_state(state)
```

---

## 13. 总结

本策略通过：
- 多时间窗互斥分桶
- 每日预算控制
- 多次随机消耗
- 覆盖率上限
- 节奏与比例扰动

在“仅能获取最近 100 条动态”的前提下，最大程度降低机器人行为特征，适合长期、稳定运行。

---

（文档结束）
